{"version":"1","records":[{"hierarchy":{"lvl1":"Introduction"},"type":"lvl1","url":"/introduction-1","position":0},{"hierarchy":{"lvl1":"Introduction"},"content":"Herein, we will walk you through the basics of finite elements and their implementation\nusing FEniCSx through its python interface.","type":"content","url":"/introduction-1","position":1},{"hierarchy":{"lvl1":"Why mixed formulations ?"},"type":"lvl1","url":"/mixed-formulations","position":0},{"hierarchy":{"lvl1":"Why mixed formulations ?"},"content":"Previously, we have solved the classical Poisson equation, using a primal formulation.\nIf this approach produces good results in most cases, it has a major drawback.\nIndeed, when using for instance 1st order Lagrange elements for the pressure p,\nthe gradient \\nabla p is piecewise constant per element.\nIn particular, the normal flux is not conserved at the interface between two elements.\nIn the case of a mass flux, this means that the local mass balance is not necessarily satisfied.\nMass balanced is only ensured in an averaged sense.\nWhen conductivity is low, this can lead to spurious oscillations in the solution, as we shall demonstrate hereafter.\n\nIntroducing a so-called mixed formulation (with pressure and flux both unknown) can solve this issue by using vector elements for the\nflux which preserve the normal component of the flux between elements, ensuring local mass balance.","type":"content","url":"/mixed-formulations","position":1},{"hierarchy":{"lvl1":"Why mixed formulations ?","lvl2":"An example of oscillating solution"},"type":"lvl2","url":"/mixed-formulations#an-example-of-oscillating-solution","position":2},{"hierarchy":{"lvl1":"Why mixed formulations ?","lvl2":"An example of oscillating solution"},"content":"To illustrate the shortcomings of the primal formulation, we will produce an example leading to an oscillating solution.\n\n\n\n","type":"content","url":"/mixed-formulations#an-example-of-oscillating-solution","position":3},{"hierarchy":{"lvl1":"Why mixed formulations ?","lvl2":"Mixed formulation for the Poisson equation"},"type":"lvl2","url":"/mixed-formulations#mixed-formulation-for-the-poisson-equation","position":4},{"hierarchy":{"lvl1":"Why mixed formulations ?","lvl2":"Mixed formulation for the Poisson equation"},"content":"We are looking to solve the following equation:(E): \\left\\{\n\\begin{aligned}\n-\\kappa\\Delta u &= 0 \\ &\\text{on }\\Omega, \\\\\nu &= u_0 \\ &\\text{on }\\Gamma_D, \\\\\n\\partial_n u &= 0 \\ &\\text{on }\\Gamma_N.\n\\end{aligned}\n\\right.\n\nWe will introduce \\underline{w} =-\\kappa\\underline{\\nabla u}, and rewrite the problem as:\\left\\{\n\\begin{aligned}\n\\underline{\\nabla}\\cdot \\underline{w} &= 0 \\ &\\text{on }\\Omega, \\\\\n\\underline{w} &= -\\kappa\\underline{\\nabla u} \\ &\\text{on }\\Omega, \\\\\nu &= u_0 \\ &\\text{on }\\Gamma_D,\\\\\nw &= 0 \\ &\\text{on }\\Gamma_N.\n\\end{aligned}\n\\right.\n\nLet us multiply by the test functions.\n\n\\forall \\underline{\\tilde{w}} \\in H^1_N(\\mathrm{div},\\Omega):\\int_\\Omega \\underline{w}\\cdot\\underline{\\tilde{w}}\\:\\mathrm{d}V - \\kappa\\int_\\Omega\\underline{\\nabla u}\\cdot\\underline{\\tilde{w}}\\:\\mathrm{d}V = 0\n\n\\Rightarrow \\frac{1}{\\kappa}\\int_\\Omega\\underline{w}\\cdot\\underline{\\tilde{w}}\\:\\mathrm{d}V + \\int_\\Omega u (\\underline{\\nabla}\\cdot\\underline{\\tilde{w}})\\:\\mathrm{d}V = \\int_\\Gamma u( \\underline{\\tilde{w}}\\cdot\\underline{n})\\:\\mathrm{d}S,\n\nand \\forall \\tilde{u} \\in H^1(\\Omega):\\int_\\Omega (\\underline{\\nabla}\\cdot\\underline{w})\\tilde{u}\\:\\mathrm{d}V = 0.","type":"content","url":"/mixed-formulations#mixed-formulation-for-the-poisson-equation","position":5},{"hierarchy":{"lvl1":"Why mixed formulations ?","lvl2":"Boundary conditions in the mixed formulation"},"type":"lvl2","url":"/mixed-formulations#boundary-conditions-in-the-mixed-formulation","position":6},{"hierarchy":{"lvl1":"Why mixed formulations ?","lvl2":"Boundary conditions in the mixed formulation"},"content":"In the boundary integral, we can split in two terms, on \\Gamma_D where u is known and \\Gamma_N where the flux w is known.\nWe realize that the essential boundary condition u = u_0 on \\Gamma_D from the primal formulation actually becomes a natural boundary condition in the mixed formulation, whereas the natural boundary conditions from the primal formulation become essential boundary conditions on the flux w:\\frac{1}{\\kappa}\\int_\\Omega\\underline{w}\\cdot\\underline{\\tilde{w}}\\:\\mathrm{d}V + \\int_\\Omega u (\\underline{\\nabla}\\cdot\\underline{\\tilde{w}})\\:\\mathrm{d}V = \\int_{\\Gamma_D} u_0( \\underline{\\tilde{w}}\\cdot\\underline{n})\\:\\mathrm{d}S","type":"content","url":"/mixed-formulations#boundary-conditions-in-the-mixed-formulation","position":7},{"hierarchy":{"lvl1":"Implementation"},"type":"lvl1","url":"/mixed-formulations-2","position":0},{"hierarchy":{"lvl1":"Implementation"},"content":"import ufl\nfrom dolfinx import mesh, fem, io, default_scalar_type, plot\nfrom dolfinx.fem.petsc import LinearProblem\nfrom mpi4py import MPI\nimport numpy as np\nimport basix\nimport pyvista\npyvista.set_jupyter_backend('static')\n\n# Mesh\ndomain = mesh.create_unit_square(\n    MPI.COMM_WORLD, 8, 8\n)  # coarse to exaggerate oscillations\n\n# Elements\norder = 2\nV_el = basix.ufl.element(\"BDM\", domain.basix_cell(), order)  # flux q\nP_el = basix.ufl.element(\"DG\", domain.basix_cell(), order - 1)  # pressure p\nW = fem.functionspace(domain, basix.ufl.mixed_element([V_el, P_el]))\n\n(q, p) = ufl.TrialFunctions(W)\n(q_, p_) = ufl.TestFunctions(W)\n\n# Material\nkappa = 1e-10  # very low permeability\nmu_f = 1.0  # fluid viscosity\n\n\n# Boundary conditions: pressure on left/right\ndef left(x):\n    return np.isclose(x[0], 0.0)\n\n\ndef right(x):\n    return np.isclose(x[0], 1.0)\n\n\ndef top(x):\n    return np.isclose(x[1], 1.0)\n\n\ndef bottom(x):\n    return np.isclose(x[1], 0.0)\n\n\nleft_facets = mesh.locate_entities_boundary(domain, 1, left)\nright_facets = mesh.locate_entities_boundary(domain, 1, right)\ntop_facets = mesh.locate_entities_boundary(domain, 1, top)\nbottom_facets = mesh.locate_entities_boundary(domain, 1, bottom)\nQ, _ = W.sub(0).collapse()\ntop_dofs_q = fem.locate_dofs_topological((W.sub(0), Q), 1, top_facets)\nbottom_dofs_q = fem.locate_dofs_topological((W.sub(0), Q), 1, bottom_facets)\n\nbc_top = fem.dirichletbc(fem.Function(Q), top_dofs_q, W.sub(0))\nbc_bottom = fem.dirichletbc(fem.Function(Q), bottom_dofs_q, W.sub(0))\n\nfacet_tags = mesh.meshtags(domain, 1, left_facets, np.full_like(left_facets, 1))\nds = ufl.Measure(\"ds\", domain=domain, subdomain_data=facet_tags)\n\n# Weak form (Darcy)\na = (\n    ufl.inner((mu_f / kappa) * q, q_) * ufl.dx\n    - ufl.inner(p, ufl.div(q_)) * ufl.dx\n    + ufl.inner(ufl.div(q), p_) * ufl.dx\n)\nn = ufl.FacetNormal(domain)\nL = -ufl.inner(fem.Constant(domain, default_scalar_type(2.0)), ufl.dot(q_, n)) * ds(1)\n\nbcs = [bc_top, bc_bottom]\n\n# Solve\nproblem = LinearProblem(a, L, bcs=bcs)\nw = problem.solve()\nCG1 = fem.functionspace(domain, (\"CG\", 1))\np_h = fem.Function(CG1, name=\"Pressure\")\np_h.interpolate(w.sub(1).collapse())\n\npyvista.start_xvfb()\nu_topology, u_cell_types, u_geometry = plot.vtk_mesh(CG1)\nu_grid = pyvista.UnstructuredGrid(u_topology, u_cell_types, u_geometry)\nu_grid.point_data[\"u\"] = p_h.x.array.real\nu_grid.set_active_scalars(\"u\")\nu_plotter = pyvista.Plotter()\nu_plotter.add_mesh(u_grid, show_edges=True)\nu_plotter.view_xy()\nu_plotter.show()","type":"content","url":"/mixed-formulations-2","position":1},{"hierarchy":{"lvl1":"Variational formulations: the Poisson equation"},"type":"lvl1","url":"/poisson","position":0},{"hierarchy":{"lvl1":"Variational formulations: the Poisson equation"},"content":"","type":"content","url":"/poisson","position":1},{"hierarchy":{"lvl1":"Variational formulations: the Poisson equation","lvl2":"Problem statement"},"type":"lvl2","url":"/poisson#problem-statement","position":2},{"hierarchy":{"lvl1":"Variational formulations: the Poisson equation","lvl2":"Problem statement"},"content":"\\left\\{\n\\begin{aligned}\n-\\Delta u &= f \\ &\\text{on }\\Omega, \\\\\nu &= 0 \\ &\\text{on }\\Gamma_D, \\\\\n\\partial_n u &= 0 \\ &\\text{on }\\Gamma_N.\n\\end{aligned}\n\\right.","type":"content","url":"/poisson#problem-statement","position":3},{"hierarchy":{"lvl1":"Variational formulations: the Poisson equation","lvl2":"Weak formulation"},"type":"lvl2","url":"/poisson#weak-formulation","position":4},{"hierarchy":{"lvl1":"Variational formulations: the Poisson equation","lvl2":"Weak formulation"},"content":"The weak formulation is obtained by multiplying by a test function v \\in H_0^1(\\Omega) and integrating over \\Omega:-\\int_\\Omega \\Delta u\\: v \\:\\mathrm{d}V = \\int_\\Omega f v\\:\\mathrm{d}V.\n\nUsing Green’s theorem, we can express the left-hand term as:-\\int_\\Omega \\Delta u\\: v \\:\\mathrm{d}V = \\int_\\Omega \\underline{\\nabla u}\\cdot\\underline{\\nabla v}\\:\\mathrm{d}V - \\int_{\\partial\\Omega} \\partial_n u\\:v\\:\\mathrm{d}S,\n\nResulting in the following weak formulation:\\int_\\Omega \\underline{\\nabla u}\\cdot\\underline{\\nabla v}\\:\\mathrm{d}V = \\int_\\Omega f v\\:\\mathrm{d}V + \\int_{\\partial\\Omega} \\partial_n u\\:v\\:\\mathrm{d}S.\n\nHowever, in the case of our problem, \\partial_n u =0 on \\Gamma_N and v=0 on \\Gamma_D so that the last term is null as \\partial\\Omega = \\Gamma_D \\cup \\Gamma_N.","type":"content","url":"/poisson#weak-formulation","position":5},{"hierarchy":{"lvl1":"Variational formulations: the Poisson equation","lvl2":"Boundary conditions"},"type":"lvl2","url":"/poisson#boundary-conditions","position":6},{"hierarchy":{"lvl1":"Variational formulations: the Poisson equation","lvl2":"Boundary conditions"},"content":"We distinguish two types of boundardy conditions: ones which are applied directly to the definition space of the function (Dirichlet boudnary conditions, also called essential boundary conditions), and conditions enforced in the weak formulation which appear when using Green’s theorem (called Neumann or natural boundary conditions). The latter is enforced through the weak form.","type":"content","url":"/poisson#boundary-conditions","position":7},{"hierarchy":{"lvl1":"Poroelasticity"},"type":"lvl1","url":"/poroelasticity-1","position":0},{"hierarchy":{"lvl1":"Poroelasticity"},"content":"In this section, we will build a simple poroelastic problem using a pure FEniCS implementation.","type":"content","url":"/poroelasticity-1","position":1},{"hierarchy":{"lvl1":"Stationary nonlinear heat transfer"},"type":"lvl1","url":"/nonlinear-heat-transfer","position":0},{"hierarchy":{"lvl1":"Stationary nonlinear heat transfer"},"content":"This demo shows how to use a simple MFront behaviour to solve a non-linear sationary heat transfer equation with dolfinx_materials.","type":"content","url":"/nonlinear-heat-transfer","position":1},{"hierarchy":{"lvl1":"Stationary nonlinear heat transfer","lvl2":"Description of the non-linear constitutive heat transfer law"},"type":"lvl2","url":"/nonlinear-heat-transfer#description-of-the-non-linear-constitutive-heat-transfer-law","position":2},{"hierarchy":{"lvl1":"Stationary nonlinear heat transfer","lvl2":"Description of the non-linear constitutive heat transfer law"},"content":"The thermal material is described by the following non linear Fourier\nLaw:\\mathbf{j}=-k\\left(T\\right)\\,\\mathbf{\\nabla} T\n\nwhere \\mathbf{j} is the heat flux and \\mathbf{\\nabla} T is the\ntemperature gradient.","type":"content","url":"/nonlinear-heat-transfer#description-of-the-non-linear-constitutive-heat-transfer-law","position":3},{"hierarchy":{"lvl1":"Stationary nonlinear heat transfer","lvl3":"Expression of the thermal conductivity","lvl2":"Description of the non-linear constitutive heat transfer law"},"type":"lvl3","url":"/nonlinear-heat-transfer#expression-of-the-thermal-conductivity","position":4},{"hierarchy":{"lvl1":"Stationary nonlinear heat transfer","lvl3":"Expression of the thermal conductivity","lvl2":"Description of the non-linear constitutive heat transfer law"},"content":"The thermal conductivity is assumed to be given by:k\\left(T\\right)={\\displaystyle \\frac{\\displaystyle 1}{\\displaystyle A+B\\,T}}\n\nThis expression accounts for the phononic contribution to the thermal\nconductivity.","type":"content","url":"/nonlinear-heat-transfer#expression-of-the-thermal-conductivity","position":5},{"hierarchy":{"lvl1":"Stationary nonlinear heat transfer","lvl3":"Derivatives","lvl2":"Description of the non-linear constitutive heat transfer law"},"type":"lvl3","url":"/nonlinear-heat-transfer#derivatives","position":6},{"hierarchy":{"lvl1":"Stationary nonlinear heat transfer","lvl3":"Derivatives","lvl2":"Description of the non-linear constitutive heat transfer law"},"content":"As discussed below, the consistent linearisation of the heat transfer\nequilibrium requires to compute:\n\nthe derivative\n{\\displaystyle \\frac{\\displaystyle \\partial \\mathbf{j}}{\\displaystyle \\partial \\mathbf{\\nabla} T}}\nof the heat flux with respect to the temperature gradient.\n{\\displaystyle \\frac{\\displaystyle \\partial \\mathbf{j}}{\\displaystyle \\partial \\mathbf{\\nabla} T}}\nis given by: {\\displaystyle \\frac{\\displaystyle \\partial \\mathbf{j}}{\\displaystyle \\partial \\mathbf{\\nabla} T}}=-k\\left(T\\right)\\,I\n\nthe derivative\n{\\displaystyle \\frac{\\displaystyle \\partial \\mathbf{j}}{\\displaystyle \\partial T}}\nof the heat flux with respect to the temperature.\n{\\displaystyle \\frac{\\displaystyle \\partial \\mathbf{j}}{\\displaystyle \\partial T}}\nis given by: {\\displaystyle \\frac{\\displaystyle \\partial \\mathbf{j}}{\\displaystyle \\partial T}}=-{\\displaystyle \\frac{\\displaystyle \\partial k\\left(T\\right)}{\\displaystyle \\partial T}}\\,\\mathbf{\\nabla} T=B\\,k^{2}\\,\\mathbf{\\nabla} T","type":"content","url":"/nonlinear-heat-transfer#derivatives","position":7},{"hierarchy":{"lvl1":"Stationary nonlinear heat transfer","lvl2":"MFront implementation"},"type":"lvl2","url":"/nonlinear-heat-transfer#mfront-implementation","position":8},{"hierarchy":{"lvl1":"Stationary nonlinear heat transfer","lvl2":"MFront implementation"},"content":"","type":"content","url":"/nonlinear-heat-transfer#mfront-implementation","position":9},{"hierarchy":{"lvl1":"Stationary nonlinear heat transfer","lvl3":"Choice of the the domain specific language","lvl2":"MFront implementation"},"type":"lvl3","url":"/nonlinear-heat-transfer#choice-of-the-the-domain-specific-language","position":10},{"hierarchy":{"lvl1":"Stationary nonlinear heat transfer","lvl3":"Choice of the the domain specific language","lvl2":"MFront implementation"},"content":"Every MFront file is handled by a domain specific language (DSL), which\naims at providing the most suitable abstraction for a particular choice\nof behaviour and integration algorithm. See mfront mfront --list-dsl\nfor a list of the available DSLs.\n\nThe name of DSL’s handling generic behaviours ends with\nGenericBehaviour. The first part of a DSL’s name is related to the\nintegration algorithm used.\n\nIn the case of this non linear transfer behaviour, the heat flux is\nexplicitly computed from the temperature and the temperature gradient.\nThe DefaultGenericBehaviour is the most suitable choice:@DSL DefaultGenericBehaviour;","type":"content","url":"/nonlinear-heat-transfer#choice-of-the-the-domain-specific-language","position":11},{"hierarchy":{"lvl1":"Stationary nonlinear heat transfer","lvl3":"Some metadata","lvl2":"MFront implementation"},"type":"lvl3","url":"/nonlinear-heat-transfer#some-metadata","position":12},{"hierarchy":{"lvl1":"Stationary nonlinear heat transfer","lvl3":"Some metadata","lvl2":"MFront implementation"},"content":"The following lines define the name of the behaviour, the name of the\nauthor and the date of its writing:@Behaviour StationaryHeatTransfer;\n@Author Thomas Helfer;\n@Date 15/02/2019;","type":"content","url":"/nonlinear-heat-transfer#some-metadata","position":13},{"hierarchy":{"lvl1":"Stationary nonlinear heat transfer","lvl3":"Gradients and fluxes","lvl2":"MFront implementation"},"type":"lvl3","url":"/nonlinear-heat-transfer#gradients-and-fluxes","position":14},{"hierarchy":{"lvl1":"Stationary nonlinear heat transfer","lvl3":"Gradients and fluxes","lvl2":"MFront implementation"},"content":"Generic behaviours relate pairs of gradients and fluxes. Gradients and\nfluxes are declared independently but the first declared gradient is\nassumed to be conjugated with the first declared fluxes and so on…\n\nThe temperature gradient is declared as follows (note that Unicode characters are supported):@Gradient TemperatureGradient ∇T;\n∇T.setGlossaryName(\"TemperatureGradient\");\n\nNote that we associated to ∇T the glossary name TemperatureGradient.\nThis is helpful for the calling code.\n\nAfter this declaration, the following variables will be defined:\n\nThe temperature gradient ∇T at the beginning of the time step.\n\nThe increment of the temperature gradient Δ∇T over the time step.\n\nThe heat flux is then declared as follows:@Flux HeatFlux j;\nj.setGlossaryName(\"HeatFlux\");\n\nIn the following code blocks, j will be the heat flux at the end of\nthe time step.","type":"content","url":"/nonlinear-heat-transfer#gradients-and-fluxes","position":15},{"hierarchy":{"lvl1":"Stationary nonlinear heat transfer","lvl3":"Tangent operator blocks","lvl2":"MFront implementation"},"type":"lvl3","url":"/nonlinear-heat-transfer#tangent-operator-blocks","position":16},{"hierarchy":{"lvl1":"Stationary nonlinear heat transfer","lvl3":"Tangent operator blocks","lvl2":"MFront implementation"},"content":"By default, the derivatives of the gradients with respect to the fluxes\nare declared. Thus the variable ∂j∕∂Δ∇T is automatically declared.\n\nHowever, as discussed in the next section, the consistent linearisation\nof the thermal equilibrium requires to return the derivate of the heat\nflux with respect to the increment of the temperature (or equivalently\nwith respect to the temperature at the end of the time step).@AdditionalTangentOperatorBlock ∂j∕∂ΔT;","type":"content","url":"/nonlinear-heat-transfer#tangent-operator-blocks","position":17},{"hierarchy":{"lvl1":"Stationary nonlinear heat transfer","lvl3":"Parameters","lvl2":"MFront implementation"},"type":"lvl3","url":"/nonlinear-heat-transfer#parameters","position":18},{"hierarchy":{"lvl1":"Stationary nonlinear heat transfer","lvl3":"Parameters","lvl2":"MFront implementation"},"content":"The A and B coefficients that appears in the definition of the\nthermal conductivity are declared as parameters:@Parameter real A = 0.0375;\n@Parameter real B = 2.165e-4;\n\nParameters are stored globally and can be modified from the calling\nsolver or from python in the case of the coupling with FEniCS\ndiscussed below.","type":"content","url":"/nonlinear-heat-transfer#parameters","position":19},{"hierarchy":{"lvl1":"Stationary nonlinear heat transfer","lvl3":"Local variable","lvl2":"MFront implementation"},"type":"lvl3","url":"/nonlinear-heat-transfer#local-variable","position":20},{"hierarchy":{"lvl1":"Stationary nonlinear heat transfer","lvl3":"Local variable","lvl2":"MFront implementation"},"content":"A local variable is accessible in each code blocks.\n\nHere, we declare the thermal conductivity k as a local variable in\norder to be able to compute its value during the behaviour integration\nand to reuse this value when computing the tangent operator.@LocalVariable thermalconductivity k;","type":"content","url":"/nonlinear-heat-transfer#local-variable","position":21},{"hierarchy":{"lvl1":"Stationary nonlinear heat transfer","lvl3":"Integration of the behaviour","lvl2":"MFront implementation"},"type":"lvl3","url":"/nonlinear-heat-transfer#integration-of-the-behaviour","position":22},{"hierarchy":{"lvl1":"Stationary nonlinear heat transfer","lvl3":"Integration of the behaviour","lvl2":"MFront implementation"},"content":"The behaviour integration is straightforward: one starts to compute the\ntemperature at the end of the time step, then we compute the thermal\nconductivity (at the end of the time step) and the heat flux using the\ntemperature gradient (at the end of the time step).@Integrator{\n  // temperature at the end of the time step\n  const auto T_ = T + ΔT;\n  // thermal conductivity\n  k = 1 / (A + B ⋅ T_);\n  // heat flux\n  j = -k ⋅ (∇T + Δ∇T);\n} // end of @Integrator","type":"content","url":"/nonlinear-heat-transfer#integration-of-the-behaviour","position":23},{"hierarchy":{"lvl1":"Stationary nonlinear heat transfer","lvl3":"Tangent operator","lvl2":"MFront implementation"},"type":"lvl3","url":"/nonlinear-heat-transfer#tangent-operator","position":24},{"hierarchy":{"lvl1":"Stationary nonlinear heat transfer","lvl3":"Tangent operator","lvl2":"MFront implementation"},"content":"The computation of the tangent operator blocks is equally simple:@TangentOperator {\n  ∂j∕∂Δ∇T = -k ⋅ tmatrix<N, N, real>::Id();\n  ∂j∕∂ΔT  =  B ⋅ k ⋅ k ⋅ (∇T + Δ∇T);\n} // end of @TangentOperator ","type":"content","url":"/nonlinear-heat-transfer#tangent-operator","position":25},{"hierarchy":{"lvl1":"Stationary nonlinear heat transfer","lvl2":"FEniCSx implementation"},"type":"lvl2","url":"/nonlinear-heat-transfer#fenicsx-implementation","position":26},{"hierarchy":{"lvl1":"Stationary nonlinear heat transfer","lvl2":"FEniCSx implementation"},"content":"We consider a rectanglar domain with imposed temperatures Tl (resp. Tr) on the left (resp. right) boundaries. We want to solve for the temperature field T inside the domain using a P^1-interpolation. We initialize the temperature at value Tl throughout the domain.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport ufl\nfrom mpi4py import MPI\nfrom dolfinx import fem, mesh\nfrom dolfinx.cpp.nls.petsc import NewtonSolver\nfrom dolfinx_materials.quadrature_map import QuadratureMap\nfrom dolfinx_materials.solvers import NonlinearMaterialProblem\nfrom dolfinx_materials.material.mfront import MFrontMaterial\nimport os\n\n\ncurrent_path = os.getcwd()\n\nlength = 30e-3\nwidth = 5.4e-3\ndomain = mesh.create_rectangle(MPI.COMM_WORLD, [(0.0, 0.0), (length, width)], [100, 10])\n\nV = fem.functionspace(domain, (\"CG\", 1))\nT = fem.Function(V, name=\"Temperature\")\n\n\ndef left(x):\n    return np.isclose(x[0], 0)\n\n\ndef right(x):\n    return np.isclose(x[0], length)\n\n\nTl = 300.0\nTr = 800.0\nT.x.petsc_vec.set(Tl)\n\nleft_dofs = fem.locate_dofs_geometrical(V, left)\nright_dofs = fem.locate_dofs_geometrical(V, right)\n\nbcs = [fem.dirichletbc(Tl, left_dofs, V), fem.dirichletbc(Tr, right_dofs, V)]\n\n","type":"content","url":"/nonlinear-heat-transfer#fenicsx-implementation","position":27},{"hierarchy":{"lvl1":"Stationary nonlinear heat transfer","lvl3":"Loading the material behaviour","lvl2":"FEniCSx implementation"},"type":"lvl3","url":"/nonlinear-heat-transfer#loading-the-material-behaviour","position":28},{"hierarchy":{"lvl1":"Stationary nonlinear heat transfer","lvl3":"Loading the material behaviour","lvl2":"FEniCSx implementation"},"content":"We use the MFrontMaterial class for describing the material behaviour. The first argument corresponds to the path where material librairies have been compiled, the second correspond to the name of the behaviour (declared with @Behaviour). Finally, the modelling hypothesis is specified (default behaviour is \"3d\").\n\nmaterial = MFrontMaterial(\n    os.path.join(current_path, \"src/libBehaviour.so\"),\n    \"StationaryHeatTransfer\",\n    hypothesis=\"plane_strain\",\n)\n\nThe MFront behaviour declares the field \"TemperatureGradient\" as a Gradient variable, with its associated Flux called \"HeatFlux\". We can check that the material object retrieves MFront’s gradient and flux names, as well as the different tangent operator blocks which have been defined, namely dj_ddgT and dj_ddT in the present case:\n\nprint(material.gradients)\nprint(material.fluxes)\n\nprint([\"d{}_d{}\".format(*t) for t in material.tangent_blocks])\n\n","type":"content","url":"/nonlinear-heat-transfer#loading-the-material-behaviour","position":29},{"hierarchy":{"lvl1":"Stationary nonlinear heat transfer","lvl3":"Non-linear problem definition","lvl2":"FEniCSx implementation"},"type":"lvl3","url":"/nonlinear-heat-transfer#non-linear-problem-definition","position":30},{"hierarchy":{"lvl1":"Stationary nonlinear heat transfer","lvl3":"Non-linear problem definition","lvl2":"FEniCSx implementation"},"content":"We now define the non-linear residual form that we want to solve. After defining test and trial functions, we instantiate the QuadratureMap object which will handle the black-box constitutive equation based on the material object. We must provide the requested quadrature degree which will control the number of quadrature points used in each cell to compute the non-linear constitutive law. Here, we specify a quadrature of degree 2 (i.e. 3 Gauss points for a triangular element).\n\nT_ = ufl.TestFunction(V)\ndT = ufl.TrialFunction(V)\n\ndeg_quad = 2\nqmap = QuadratureMap(domain, deg_quad, material)\n\n","type":"content","url":"/nonlinear-heat-transfer#non-linear-problem-definition","position":31},{"hierarchy":{"lvl1":"Stationary nonlinear heat transfer","lvl4":"Variable registration","lvl3":"Non-linear problem definition","lvl2":"FEniCSx implementation"},"type":"lvl4","url":"/nonlinear-heat-transfer#variable-registration","position":32},{"hierarchy":{"lvl1":"Stationary nonlinear heat transfer","lvl4":"Variable registration","lvl3":"Non-linear problem definition","lvl2":"FEniCSx implementation"},"content":"The MFront behaviour implicitly declares the temperature as an external state variable called \"Temperature\". We must therefore associate this external state variable to a known mechanical field. This can be achieved explicitly using the register_external_state_variable method.\n\nFor problems in which the temperature only acts as a parameter (no jacobian blocks with respect to the temperature), the temperature can be automatically registered as a constant value (293.15 \\text{ K} by default) or to any other (dolfin.Constant, float or dolfin.Function) value using the register_external_state_variable method.\n\nFinally, we need to associate to MFront gradient object the corresponding UFL expression as a function of the unknown field T. To do so, we use the register_gradient method linking MFront \"TemperatureGradient\" object to the UFL expression grad(T).\n\nqmap.register_external_state_variable(\"Temperature\", T)\nqmap.register_gradient(\"TemperatureGradient\", ufl.grad(T))\n\n","type":"content","url":"/nonlinear-heat-transfer#variable-registration","position":33},{"hierarchy":{"lvl1":"Stationary nonlinear heat transfer","lvl4":"Nonlinear variational formulation","lvl3":"Non-linear problem definition","lvl2":"FEniCSx implementation"},"type":"lvl4","url":"/nonlinear-heat-transfer#nonlinear-variational-formulation","position":34},{"hierarchy":{"lvl1":"Stationary nonlinear heat transfer","lvl4":"Nonlinear variational formulation","lvl3":"Non-linear problem definition","lvl2":"FEniCSx implementation"},"content":"We are now in position of defining the nonlinear variational formulation corresponding to the stationary nonlinear heat transfer. Without any external loading, the nonlinear residual reads as:F(\\widehat{T}) = \\int_\\Omega \\mathbf{j}\\cdot \\nabla \\widehat{T} \\text{dx} = 0 \\quad \\forall \\widehat{T}\n\nwhere the heat flux \\mathbf{j} is provided by the QuadratureMap as a flux. The latter is a dolfinx function defined on Quadrature function space (no interpolation is possible). Note that the integration measure must match the chosen quadrature scheme and quadrature degree. It is provided here as qmap.dx.\n\nThe qmap.derivative function works similarly to the standard ufl.derivative function except that it will also differentiate the heat flux. From the two tangent operator blocks dj_ddgT and dj_ddT, it will automatically be deduced that the heat flux \\mathbf{j} is a function of both the temperature gradient \\mathbf{g}=\\nabla T and the temperature itself i.e. \\mathbf{j}=\\mathbf{j}(\\mathbf{g}, T). Hence, the computed Jacobian form will be:J(\\widehat{T},T^*) = \\int_{\\Omega} \\nabla \\widehat{T}\\cdot\\left(\\dfrac{\\partial \\mathbf{j}}{\\partial \\mathbf{g}}\\cdot \\nabla T^*+\\dfrac{\\partial \\mathbf{j}}{\\partial T}\\cdot T^*\\right) \\text{dx}\n\nThe resulting nonlinear problem is managed by the NonlinearMaterialProblem class. It is solved using a Newton non-linear solver. The solve method returns the converged status and the number of Newton iterations.\n\nj = qmap.fluxes[\"HeatFlux\"]\n\nF = ufl.dot(j, ufl.grad(T_)) * qmap.dx\nJac = qmap.derivative(F, T, dT)\n\nproblem = NonlinearMaterialProblem(qmap, F, Jac, T, bcs)\n\nnewton = NewtonSolver(MPI.COMM_WORLD)\n\nconverged, it = problem.solve(newton)\n\n# Problem is weakly nonlinear, it should converge in a few iterations\nassert converged and it < 10\n\nWe finally check that the thermal conductivity coefficient k, computed from the ratio between the horizontal heat flux and temperature gradient matches the temperature-dependent expressions implemented in the MFront behaviour.\n\nj_vals = j.x.array\ng_vals = qmap.gradients[\"TemperatureGradient\"].function.x.array\nk_gauss = -j_vals[::2] / g_vals[::2]\nT_gauss = qmap.external_state_variables[\"Temperature\"].function.x.array\nA = material.get_parameter(\"A\")\nB = material.get_parameter(\"B\")\nk_ref = 1 / (A + B * T_gauss)\nplt.plot(T_gauss, k_gauss, \"o\", label=\"FE\")\nplt.plot(T_gauss, k_ref, \".\", label=\"ref\")\nplt.xlabel(r\"Temperature $T\\: (K)$\")\nplt.ylabel(r\"Thermal conductivity $k\\: (W.m^{-1}.K^{-1})$\")\nplt.legend()\nplt.show()","type":"content","url":"/nonlinear-heat-transfer#nonlinear-variational-formulation","position":35},{"hierarchy":{"lvl1":""},"type":"lvl1","url":"/poroelasticity-2","position":0},{"hierarchy":{"lvl1":""},"content":"from dolfinx import mesh, fem, default_scalar_type, io\nimport ufl\nimport basix\nfrom dolfinx.cpp.nls.petsc import NewtonSolver\nfrom mpi4py import MPI\nfrom petsc4py import PETSc\nimport numpy as np\nfrom dolfinx_materials.quadrature_map import QuadratureMap\nfrom dolfinx_materials.solvers import NonlinearMaterialProblem\nfrom dolfinx_materials.material.mfront import MFrontMaterial\nfrom dolfinx_materials.utils import symmetric_tensor_to_vector\nimport os\ncurrent_path = os.getcwd()\n\n\nL, H = 0.1, 0.1\nNx, Ny = 20, 20\n\ndomain = mesh.create_rectangle(MPI.COMM_WORLD, [[0,0], [L,H]], [Nx,Ny], mesh.CellType.quadrilateral)\nx = ufl.SpatialCoordinate(domain)\ndef axi_grad(u):\n    return ufl.as_vector([u[0].dx(0), u[1].dx(1), u[0]/x[0], (u[0].dx(1)+u[1].dx(0))/2])\n\nmat_prop = {\n    \"YoungModulus\": 6e9,\n    \"PoissonRatio\": 0.2,\n    \"BiotCoefficient\": 0.6,\n    \"BiotN\": 3.1e10,\n    \"LiquidPermeability\": 5e-16,\n    \"InitialPorosity\": 0.2,\n}\nmaterial = MFrontMaterial(\n    os.path.join(current_path, \"src/libBehaviour.so\"),\n    \"PoroElasticity_Maxime\",\n    hypothesis=\"plane_strain\",\n    material_properties = mat_prop,\n)\n\ndisp_el = basix.ufl.element(\"Lagrange\", domain.basix_cell(), 1, shape=(2,))\nfluid_el = basix.ufl.element(\"Lagrange\", domain.basix_cell(), 1)\nV = fem.functionspace(domain, basix.ufl.mixed_element([disp_el, fluid_el]))\nv = fem.Function(V, name=\"Unknown\")\n\ndef bottom(x):\n    return np.isclose(x[1], 0)\ndef top(x):\n    return np.isclose(x[1], H)\ndef left(x):\n    return np.isclose(x[0], 0)\n\n\nbottom_facets = mesh.locate_entities_boundary(domain, 1, bottom)\nbottom_dofs_y = fem.locate_dofs_topological(V.sub(0).sub(1), 1, bottom_facets)\ntop_facets = mesh.locate_entities_boundary(domain, 1, top)\npf_ini = 0e6\ntop_dofs_pf = fem.locate_dofs_topological(V.sub(1), 1, top_facets)\nbc_pf_top = fem.dirichletbc(pf_ini, top_dofs_pf, V.sub(1))\n\nbcs = [\n    fem.dirichletbc(default_scalar_type(0), bottom_dofs_y, V.sub(0).sub(1)),\n    bc_pf_top\n]\n\nfacet_tags = mesh.meshtags(domain, 1, top_facets, np.full_like(top_facets, 1))\n\nds = ufl.Measure(\"ds\", domain=domain, subdomain_data=facet_tags, metadata={\"quadrature degree\": 2})\nf = fem.Constant(domain, np.zeros((2,)))\n\nqmap = QuadratureMap(domain, 2, material)\n\n(u, pl) = ufl.split(v)\nqmap.register_gradient(\"Strain\", symmetric_tensor_to_vector(ufl.sym(ufl.grad(u))))\nqmap.register_external_state_variable(\"LiquidPressure\", pl)\nqmap.register_gradient(\"LiquidPressureGradient\", ufl.grad(pl))\n\nsig = qmap.fluxes[\"Stress\"]\nw = qmap.fluxes[\"FluidFlux\"]\nml = qmap.internal_state_variables[\"LiquidMass\"]\nml_n = ml.copy()\ndt = fem.Constant(domain, 0.0)\n\nv_ = ufl.TestFunction(V)\n(u_, pl_) = ufl.split(v_)\ndv = ufl.TrialFunction(V)\n\nF = (ufl.dot(sig, symmetric_tensor_to_vector(ufl.sym(ufl.grad(u_))))) * qmap.dx + ( (ml-ml_n)/dt*pl_ - ufl.dot(w, ufl.grad(pl_)))*qmap.dx -ufl.dot(f, u_)*ds(1)\n\nJac = qmap.derivative(F, v, dv)\n\nproblem = NonlinearMaterialProblem(qmap, F, Jac, v, bcs)\n\nqmap.update()\nml.x.petsc_vec.copy(ml_n.x.petsc_vec)\n\nnewton = NewtonSolver(MPI.COMM_WORLD)\nnewton.rtol = 1e-6\nnewton.atol = 1e-6\nnewton.convergence_criterion = \"incremental\"\nnewton.report = True\nnewton.max_it = 50\n\nNincr = 20\nload_steps = np.linspace(0.0, 1.0, Nincr + 1)\n\nvtk_u = io.VTKFile(domain.comm, \"results/results_u.pvd\", \"w\")\nvtk_p = io.VTKFile(domain.comm, \"results/results_p.pvd\", \"w\")\nvtk_sig = io.VTKFile(domain.comm, \"results/results_sig.pvd\", \"w\")\nfor i, t in enumerate(load_steps[1:]):\n    f.value[-1] = -1e7 * t\n    dt.value = 1/Nincr\n\n    converged, it = problem.solve(newton, print_solution=True)\n    ml.x.petsc_vec.copy(ml_n.x.petsc_vec)\n    u_out = v.sub(0).collapse()\n    u_out.name = \"Displacement\"\n    p_out = v.sub(1).collapse()\n    p_out.name = \"Pressure\"\n    stress_out = qmap.project_on(\"Stress\", (\"DG\",0))\n    vtk_u.write_function(u_out, t)\n    vtk_p.write_function(p_out, t)\n    vtk_sig.write_function(stress_out, t)\n\nvtk_u.close()\nvtk_p.close()\nvtk_sig.close()","type":"content","url":"/poroelasticity-2","position":1},{"hierarchy":{"lvl1":"Introduction"},"type":"lvl1","url":"/introduction-2","position":0},{"hierarchy":{"lvl1":"Introduction"},"content":"","type":"content","url":"/introduction-2","position":1},{"hierarchy":{"lvl1":"A simple elastic behaviour"},"type":"lvl1","url":"/elasticity","position":0},{"hierarchy":{"lvl1":"A simple elastic behaviour"},"content":"","type":"content","url":"/elasticity","position":1},{"hierarchy":{"lvl1":"A simple elastic behaviour","lvl2":"MFront implementation"},"type":"lvl2","url":"/elasticity#mfront-implementation","position":2},{"hierarchy":{"lvl1":"A simple elastic behaviour","lvl2":"MFront implementation"},"content":"To give a first introduction to writing material behaviors using MFront, we will implement a very simple linear elastic model :\\tens{\\sigma} = \\lambda\\:\\mathrm{tr}(\\tens{\\varepsilon})\\tens{I}+2\\mu\\tens{\\varepsilon},\n\nwhere \\lambda and \\mu are the Lamé coefficients.\nThe parameters of the model will be Young’s modulus E and Poisson’s ration \\nu, while the output will be the Cauchy stress tensor \\tens{\\sigma}.\nOf course, we could use one of Mfront’s standard brick for this purpose, but the idea here is to define everything ourselves.\n\nHere is a look at the corresponding elasticity.mfront file:@DSL DefaultGenericBehaviour;\n@Author Maxime Pierre;\n@Date 22/11/2025;\n\n@Behaviour Elasticity;\n\nFirst, we specify the domain specific language (DSL) that we want to use.\nIt will condition what keywords we will have access to in the rest of the file.\nAfter optionally declaring an author and a date, we give a name to our behaviour (Elasticity).\n\nNext, we define the input and output variables of our model : the strain tensor \\tens{\\varepsilon} (a gradient of the displacement), and its associated flux which is the stress tensor \\tens{\\sigma}.@Gradient StrainStensor εᵗᵒ;\nεᵗᵒ.setGlossaryName(\"Strain\");\n\n@Flux StressStensor σ;\nσ.setGlossaryName(\"Stress\");\n\nThen, we define the material properties which must be passed to the behaviour:@MaterialProperty stress E;\nE.setGlossaryName(\"YoungModulus\");\n\n@MaterialProperty real ν;\nν.setGlossaryName(\"PoissonRatio\");\n\nNaming variables in MFront\n\nNote that all the names of variables and properties used so far are very common, and part of the standard glossary of MFront. They are therefore applied using the setGlossaryName method. For names which are not part of the glossary, any name can be applied using the setEntryName method instead.\n\nNow, we define the blocks composing the tangent operator.\nIn our simple case, their is only one, \\partial\\tens{\\sigma}/\\partial\\tens{\\varepsilon}, which corresponds to the stiffness tensor \\mathbb{C}.@TangentOperatorBlocks{∂σ∕∂Δεᵗᵒ};\n@ProvidesTangentOperator ;\n\nFinally, we enter the core of the behaviour with the Integrator block.\nThis is where the behaviour of the material is actually calculated.\nMFront provides some helper functions to calculate Lamé’s coefficients from E and \\nu.\nThen, we calculate the stress with an incremental formulation (note that in the case of elasticity, a total formulation would also have been acceptable).\nThe last part gives the one tangent operator block that was declared above.@Integrator{\n  const auto λ = computeLambda(E, ν);\n  const auto μ = computeMu(E, ν);\n  σ += λ ⋅ trace(Δεᵗᵒ) ⋅ I₂ + 2 ⋅ μ ⋅ Δεᵗᵒ ;\n\n  if (computeTangentOperator_) {\n    ∂σ∕∂Δεᵗᵒ = λ ⋅ (I₂ ⊗ I₂) + 2 ⋅ μ ⋅ I₄;\n  }\n}\n\n","type":"content","url":"/elasticity#mfront-implementation","position":3},{"hierarchy":{"lvl1":"A simple elastic behaviour","lvl2":"Compiling a behaviour"},"type":"lvl2","url":"/elasticity#compiling-a-behaviour","position":4},{"hierarchy":{"lvl1":"A simple elastic behaviour","lvl2":"Compiling a behaviour"},"content":"Once the .mfront file is written, we need to compile it to create a shared library that can then be used in other contexts (mtest, python, FEniCS...).\nThis can be done from the terminal using the following command:mfront --obuild --interface=generic elasticity.mfront\n\nHere, we used the generic interface, which is the one used to plug the constitutive laws into python or FEniCS using MGIS, the MFront Generic Interface Support.\nThe command creates or updates a shared library src/libBehaviour.so on Linux or src/libBehaviour.dylib on MacOS (note the difference in extension for dynamic libraries).\n\n","type":"content","url":"/elasticity#compiling-a-behaviour","position":5},{"hierarchy":{"lvl1":"A simple elastic behaviour","lvl2":"Testing the behaviour with mtest"},"type":"lvl2","url":"/elasticity#testing-the-behaviour-with-mtest","position":6},{"hierarchy":{"lvl1":"A simple elastic behaviour","lvl2":"Testing the behaviour with mtest"},"content":"@Behaviour<Generic> 'src/libBehaviour.dylib' 'Elasticity';\n@MaterialProperty<constant> 'YoungModulus' 1e+10 ;\n@MaterialProperty<constant> 'PoissonRatio' 0.2 ;@ExternalStateVariable 'Temperature' 293.15 ;\n\n@ImposedDrivingVariable 'StrainXX' 0.0;\n@ImposedDrivingVariable 'StrainYY' 0.0;\n\n@ImposedThermodynamicForce 'StressZZ' {0.0: 0.0, 1.0: -1e7};\n\n@Times {0.0, 1.0 in 10};mtest elasticity.mtest\n\n","type":"content","url":"/elasticity#testing-the-behaviour-with-mtest","position":7},{"hierarchy":{"lvl1":"A simple elastic behaviour","lvl2":"Interacting with the behaviour in python"},"type":"lvl2","url":"/elasticity#interacting-with-the-behaviour-in-python","position":8},{"hierarchy":{"lvl1":"A simple elastic behaviour","lvl2":"Interacting with the behaviour in python"},"content":"Using the mtest package in python, it is possible to interact with a compiled MFront behaviour.\n\nFirst, we have to set the behaviour for our test as well as the different material properties that are necessary.\nWe chose Young’s Modulus as 10 MPa and Poisson’s ration as 0.2.\n\nfrom sys import platform\nimport std\nimport tfel.math\nimport numpy as np\nfrom mtest import (\n    MTest,\n    VerboseLevel,\n    PredictionPolicy,\n    setVerboseMode,\n    MTestCurrentState,\n    MTestWorkSpace,\n    Behaviour,\n)\n\ndef lib_ext() -> str | None:\n    if platform == \"linux\":\n        return \".so\"\n    elif platform == \"darwin\":\n        return \".dylib\"\n\nsetVerboseMode(VerboseLevel.VERBOSE_LEVEL2)\n\ntest = MTest()\nstate = MTestCurrentState()\nworkspace = MTestWorkSpace()\n\n# Setting the behaviour\nbehaviour = Behaviour(\"generic\", f\"../MFront_library/src/libBehaviour{lib_ext()}\", \"Elasticity\",\"Tridimensional\")\ntest.setBehaviour(\"generic\", f\"../MFront_library/src/libBehaviour{lib_ext()}\", \"Elasticity\")\n\n# Setting the material properties\ntest.setMaterialProperty(\"YoungModulus\", 1e10)\ntest.setMaterialProperty(\"PoissonRatio\", 0.2)\n\nNext, we set the conditions for the test. The setImposedGradient method allows to control the different components of the gradients (here strain) by their name, and the setImposedThermodynamicForce method does the same for thermodynamic forces (here stress). A single value can be provided, or a dictionary with several entries to have a variation over time, similar to the mtest syntax.\n\nWe impose oedometric conditions on the sample: x and y deformation are prevented while we apply an axial load up the 10 MPa in compression.\n\ntest.setExternalStateVariable(\"Temperature\", 293.15)\ntest.setImposedGradient(\"StrainXX\", 0.0)\ntest.setImposedGradient(\"StrainYY\", 0.0)\ntest.setImposedThermodynamicForce(\"StressZZ\", {0.0: 0.0, 1.0: -1e7})\n\ntest.completeInitialisation()\ntest.initializeCurrentState(state)\ntest.initializeWorkSpace(workspace)\n\nWe perform a simulation with 10 steps between times 0 and 1, and store the results to show the stress-strain curve of the oedometric test.\nObviously, this is a very simple test and the results is a simple line with slope E_\\mathrm{oed}.\n\nt = np.linspace(0,1,10)\nepszz_index = behaviour.getGradientComponentPosition(\"StrainZZ\")\nsigzz_index = behaviour.getThermodynamicForceComponentPosition(\"StressZZ\")\n\nepszz = [0.0]\nsigzz = [0.0]\n\nfor i in range(len(t)-1):\n    test.execute(state, workspace, t[i], t[i+1])\n    epszz.append(-state.e1[epszz_index])\n    sigzz.append(-state.s1[sigzz_index])\n\nimport matplotlib.pyplot as plt\n\nplt.plot(epszz, sigzz)\nplt.xlabel(r\"$\\varepsilon_{zz}$ [Pa]\")\nplt.ylabel(r\"$\\sigma_{zz}$ [-]\")\nplt.show()\n\nWe can compare the resulting oedometric modulus from the simulation with the analytical formula:E_\\mathrm{oed} = \\frac{E(1-\\nu)}{(1+\\nu)(1-2\\nu)}.\n\nprint(f\"Modulus from simulation: {sigzz[-1]/epszz[-1]/1e9:.2f} GPa\")\nprint(f\"Analytical oedometric modulus: {1e10*(1-0.2)/(1+0.2)/(1-2*0.2)/1e9:.2f} GPa\")","type":"content","url":"/elasticity#interacting-with-the-behaviour-in-python","position":9},{"hierarchy":{"lvl1":"Introduction"},"type":"lvl1","url":"/introduction","position":0},{"hierarchy":{"lvl1":"Introduction"},"content":"In this section, we will walk you through implementing your first behaviors at the material point using the code generator MFront. We will take advantage of its testing module mtest and its python bindings with which we will run simple simulations at the material point as illustrations.\nThis kind of tool can prove interesting when trying to calibrate a model.","type":"content","url":"/introduction","position":1},{"hierarchy":{"lvl1":"Introduction","lvl2":"Requisites"},"type":"lvl2","url":"/introduction#requisites","position":2},{"hierarchy":{"lvl1":"Introduction","lvl2":"Requisites"},"content":"To run these examples, you will need an install of MFront with the python bindings enabled.\nAn easy way is to install MFront through conda.","type":"content","url":"/introduction#requisites","position":3},{"hierarchy":{"lvl1":"Introduction","lvl2":"What is a material behavior?"},"type":"lvl2","url":"/introduction#what-is-a-material-behavior","position":4},{"hierarchy":{"lvl1":"Introduction","lvl2":"What is a material behavior?"},"content":"","type":"content","url":"/introduction#what-is-a-material-behavior","position":5},{"hierarchy":{"lvl1":"Poroelasticity: introduction to multiphysics"},"type":"lvl1","url":"/poroelasticity","position":0},{"hierarchy":{"lvl1":"Poroelasticity: introduction to multiphysics"},"content":"In this section, we will introduce a first poroelastic example.","type":"content","url":"/poroelasticity","position":1},{"hierarchy":{"lvl1":"Poroplasticity with the Cam-Clay model"},"type":"lvl1","url":"/poroplasticity","position":0},{"hierarchy":{"lvl1":"Poroplasticity with the Cam-Clay model"},"content":"","type":"content","url":"/poroplasticity","position":1},{"hierarchy":{"lvl1":"Welcome to the MFront & FEniCSx Gallery!"},"type":"lvl1","url":"/","position":0},{"hierarchy":{"lvl1":"Welcome to the MFront & FEniCSx Gallery!"},"content":"Herein, you will find resources about formulating material behaviors and running FEM simulations\nwith \n\nFEniCSx and (optionally) \n\nMFront.","type":"content","url":"/","position":1}]}